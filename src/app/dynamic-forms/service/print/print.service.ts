import { Inject, Injectable, LOCALE_ID } from "@angular/core";
import { coerceBooleanProperty } from "@angular/cdk/coercion";

import { DataFormatType } from "../../enums/data-format-type.enum";

import { DropdownOption } from "../cinchy-dropdown-dataset/cinchy-dropdown-options";

import { ChildFormService } from "../child-form/child-form.service";

import { PageOrientation } from "../../enums/page-orientation.enum";
import { PageSize } from "../../enums/page-size.enum";

import { IExportSettings } from "../../interface/export-settings";

import { Form } from "../../models/cinchy-form.model";
import { FormField } from "../../models/cinchy-form-field.model";
import { FormSection } from "../../models/cinchy-form-section.model";

import { ILookupRecord } from "../../../models/lookup-record.model";

import { AppStateService } from "../../../services/app-state.service";
import { NotificationService } from "../../../services/notification.service";

import { NgxSpinnerService } from "ngx-spinner";

import pdfMake from "pdfmake";
import pdfFonts from "pdfmake/build/vfs_fonts";

import moment from "moment";


pdfMake.addVirtualFileSystem(pdfFonts);


/**
 * Used to generate a PDF "print" of a form
 */
@Injectable({
  providedIn: "root",
})
export class PrintService {

  sectionHeaderDefault = {
    text: "RESUME",
    bold: true,
    style: "section"
  }


  styles = {
    anchor: {
      color: "#007bff",
      italics: false
    },
    formHeader: {
      bold: true,
      fontSize: 20,
      alignment: "center",
      margin: [0, 15, 0, 15]
    },
    formSubHeader: {
      bold: true,
      fontSize: 14,
      alignment: "center",
      color: "purple"
    },
    section: {
      bold: true,
      fontSize: 14,
      color: "#E7015B",
      margin: [0, 15, 0, 5]
    },
    fieldLabel: {
      fontSize: 10,
      bold: true,
      color: "#757575",
      marginBottom: 8
    },
    fieldValue: {
      fontSize: 10,
      italics: false,
      marginBottom: 8
    },
    tableHeader: {
      color: "purple",
      fontSize: 8,
      bold: true,
    },
    tableRow: {
      fontSize: 8,
    },
    footer: {
      fontSize: 8,
      marginRight: 20,
      marginBottom: 0,
      alignment: "right"
    }
  }


  content = [];


  header = {
    margin: [50, 20],
    columns: [
      {
        image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAADeCAYAAADhEH4wAAAACXBIWXMAAAsTAAALEwEAmpwYAAArvGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczppbGx1c3RyYXRvcj0iaHR0cDovL25zLmFkb2JlLmNvbS9pbGx1c3RyYXRvci8xLjAvIiB4bWxuczp4bXBUUGc9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC90L3BnLyIgeG1sbnM6c3REaW09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9EaW1lbnNpb25zIyIgeG1sbnM6eG1wRz0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL2cvIiB4bWxuczpwZGY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGRmLzEuMy8iIHhtbG5zOnBkZng9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGRmeC8xLjMvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIElsbHVzdHJhdG9yIENDIDIzLjAgKE1hY2ludG9zaCkiIHhtcDpDcmVhdGVEYXRlPSIyMDE5LTAzLTExVDE0OjA0OjA4LTA3OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxOS0xMC0wNVQwNjoxNzoyNSswODowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOS0xMC0wNVQwNjoxNzoyNSswODowMCIgeG1wTU06UmVuZGl0aW9uQ2xhc3M9InByb29mOnBkZiIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjY1RTYzOTA2ODZDRjExREJBNkUyRDg4N0NFQUNCNDA3IiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6MTg2MGY2YzQtYzRhZi02MzQ3LWE3M2ItMGI3YWNlN2U5MmJmIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmZjMmQ4YmM1LTk5NDQtOGQ0Ni1iNjY3LWY5MTk1ODUxYjNjYiIgaWxsdXN0cmF0b3I6U3RhcnR1cFByb2ZpbGU9IldlYiIgaWxsdXN0cmF0b3I6VHlwZT0iRG9jdW1lbnQiIHhtcFRQZzpOUGFnZXM9IjEiIHhtcFRQZzpIYXNWaXNpYmxlVHJhbnNwYXJlbmN5PSJGYWxzZSIgeG1wVFBnOkhhc1Zpc2libGVPdmVycHJpbnQ9IkZhbHNlIiBwZGY6UHJvZHVjZXI9IkFkb2JlIFBERiBsaWJyYXJ5IDE1LjAwIiBwZGZ4OkNyZWF0b3JWZXJzaW9uPSIyMS4wLjAiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSI+IDxkYzp0aXRsZT4gPHJkZjpBbHQ+IDxyZGY6bGkgeG1sOmxhbmc9IngtZGVmYXVsdCI+Y2luY2h5X2ZpbmFsbG9nb19kYXJrPC9yZGY6bGk+IDwvcmRmOkFsdD4gPC9kYzp0aXRsZT4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6N2ViYWY5NzItMTc3Yi0yYzQ3LTkxMDItMGU3MDdhNjQ4YWJjIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjdlYmFmOTcyLTE3N2ItMmM0Ny05MTAyLTBlNzA3YTY0OGFiYyIgc3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjY1RTYzOTA2ODZDRjExREJBNkUyRDg4N0NFQUNCNDA3IiBzdFJlZjpyZW5kaXRpb25DbGFzcz0icHJvb2Y6cGRmIi8+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjdhNTA4MDNmLTFlN2QtNGFmYS1iMzA5LWNhZDM2YmQ5MmM1YSIgc3RFdnQ6d2hlbj0iMjAxOS0wMy0wOFQxNDoxMzo0OS0wODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgSWxsdXN0cmF0b3IgQ0MgMjMuMCAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ODA5YTBiYjgtYjVlNi00YzU0LThiNzAtZDM0MjcxYTMwMWI0IiBzdEV2dDp3aGVuPSIyMDE5LTAzLTExVDE0OjA0OjA3LTA3OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBJbGx1c3RyYXRvciBDQyAyMy4wIChNYWNpbnRvc2gpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjb252ZXJ0ZWQiIHN0RXZ0OnBhcmFtZXRlcnM9ImZyb20gYXBwbGljYXRpb24vcGRmIHRvIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjdlYmFmOTcyLTE3N2ItMmM0Ny05MTAyLTBlNzA3YTY0OGFiYyIgc3RFdnQ6d2hlbj0iMjAxOS0xMC0wNVQwNjoxNzoyNSswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjb252ZXJ0ZWQiIHN0RXZ0OnBhcmFtZXRlcnM9ImZyb20gYXBwbGljYXRpb24vcGRmIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iZGVyaXZlZCIgc3RFdnQ6cGFyYW1ldGVycz0iY29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmciLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmZjMmQ4YmM1LTk5NDQtOGQ0Ni1iNjY3LWY5MTk1ODUxYjNjYiIgc3RFdnQ6d2hlbj0iMjAxOS0xMC0wNVQwNjoxNzoyNSswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8eG1wVFBnOk1heFBhZ2VTaXplIHN0RGltOnc9IjM4OS4wMDAwMDAiIHN0RGltOmg9IjE4My4wMDAwMDAiIHN0RGltOnVuaXQ9IlBpeGVscyIvPiA8eG1wVFBnOlBsYXRlTmFtZXM+IDxyZGY6U2VxPiA8cmRmOmxpPkN5YW48L3JkZjpsaT4gPHJkZjpsaT5NYWdlbnRhPC9yZGY6bGk+IDxyZGY6bGk+WWVsbG93PC9yZGY6bGk+IDxyZGY6bGk+QmxhY2s8L3JkZjpsaT4gPC9yZGY6U2VxPiA8L3htcFRQZzpQbGF0ZU5hbWVzPiA8eG1wVFBnOlN3YXRjaEdyb3Vwcz4gPHJkZjpTZXE+IDxyZGY6bGk+IDxyZGY6RGVzY3JpcHRpb24geG1wRzpncm91cE5hbWU9IkRlZmF1bHQgU3dhdGNoIEdyb3VwIiB4bXBHOmdyb3VwVHlwZT0iMCI+IDx4bXBHOkNvbG9yYW50cz4gPHJkZjpTZXE+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJXaGl0ZSIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjI1NSIgeG1wRzpncmVlbj0iMjU1IiB4bXBHOmJsdWU9IjI1NSIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iQmxhY2siIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSIwIiB4bXBHOmdyZWVuPSIwIiB4bXBHOmJsdWU9IjAiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlJHQiBSZWQiIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSIyNTUiIHhtcEc6Z3JlZW49IjAiIHhtcEc6Ymx1ZT0iMCIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUkdCIFllbGxvdyIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjI1NSIgeG1wRzpncmVlbj0iMjU1IiB4bXBHOmJsdWU9IjAiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlJHQiBHcmVlbiIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjAiIHhtcEc6Z3JlZW49IjI1NSIgeG1wRzpibHVlPSIwIi8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSR0IgQ3lhbiIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjAiIHhtcEc6Z3JlZW49IjI1NSIgeG1wRzpibHVlPSIyNTUiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlJHQiBCbHVlIiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iMCIgeG1wRzpncmVlbj0iMCIgeG1wRzpibHVlPSIyNTUiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlJHQiBNYWdlbnRhIiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iMjU1IiB4bXBHOmdyZWVuPSIwIiB4bXBHOmJsdWU9IjI1NSIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0xOTMgRz0zOSBCPTQ1IiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iMTkzIiB4bXBHOmdyZWVuPSIzOSIgeG1wRzpibHVlPSI0NSIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0yMzcgRz0yOCBCPTM2IiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iMjM3IiB4bXBHOmdyZWVuPSIyOCIgeG1wRzpibHVlPSIzNiIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0yNDEgRz05MCBCPTM2IiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iMjQxIiB4bXBHOmdyZWVuPSI5MCIgeG1wRzpibHVlPSIzNiIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0yNDcgRz0xNDcgQj0zMCIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjI0NyIgeG1wRzpncmVlbj0iMTQ3IiB4bXBHOmJsdWU9IjMwIi8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTI1MSBHPTE3NiBCPTU5IiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iMjUxIiB4bXBHOmdyZWVuPSIxNzYiIHhtcEc6Ymx1ZT0iNTkiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlI9MjUyIEc9MjM4IEI9MzMiIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSIyNTIiIHhtcEc6Z3JlZW49IjIzOCIgeG1wRzpibHVlPSIzMyIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0yMTcgRz0yMjQgQj0zMyIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjIxNyIgeG1wRzpncmVlbj0iMjI0IiB4bXBHOmJsdWU9IjMzIi8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTE0MCBHPTE5OCBCPTYzIiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iMTQwIiB4bXBHOmdyZWVuPSIxOTgiIHhtcEc6Ymx1ZT0iNjMiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlI9NTcgRz0xODEgQj03NCIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjU3IiB4bXBHOmdyZWVuPSIxODEiIHhtcEc6Ymx1ZT0iNzQiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlI9MCBHPTE0NiBCPTY5IiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iMCIgeG1wRzpncmVlbj0iMTQ2IiB4bXBHOmJsdWU9IjY5Ii8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTAgRz0xMDQgQj01NSIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjAiIHhtcEc6Z3JlZW49IjEwNCIgeG1wRzpibHVlPSI1NSIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0zNCBHPTE4MSBCPTExNSIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjM0IiB4bXBHOmdyZWVuPSIxODEiIHhtcEc6Ymx1ZT0iMTE1Ii8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTAgRz0xNjkgQj0xNTciIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSIwIiB4bXBHOmdyZWVuPSIxNjkiIHhtcEc6Ymx1ZT0iMTU3Ii8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTQxIEc9MTcxIEI9MjI2IiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iNDEiIHhtcEc6Z3JlZW49IjE3MSIgeG1wRzpibHVlPSIyMjYiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlI9MCBHPTExMyBCPTE4OCIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjAiIHhtcEc6Z3JlZW49IjExMyIgeG1wRzpibHVlPSIxODgiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlI9NDYgRz00OSBCPTE0NiIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjQ2IiB4bXBHOmdyZWVuPSI0OSIgeG1wRzpibHVlPSIxNDYiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlI9MjcgRz0yMCBCPTEwMCIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjI3IiB4bXBHOmdyZWVuPSIyMCIgeG1wRzpibHVlPSIxMDAiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlI9MTAyIEc9NDUgQj0xNDUiIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSIxMDIiIHhtcEc6Z3JlZW49IjQ1IiB4bXBHOmJsdWU9IjE0NSIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0xNDcgRz0zOSBCPTE0MyIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjE0NyIgeG1wRzpncmVlbj0iMzkiIHhtcEc6Ymx1ZT0iMTQzIi8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTE1OCBHPTAgQj05MyIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjE1OCIgeG1wRzpncmVlbj0iMCIgeG1wRzpibHVlPSI5MyIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0yMTIgRz0yMCBCPTkwIiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iMjEyIiB4bXBHOmdyZWVuPSIyMCIgeG1wRzpibHVlPSI5MCIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0yMzcgRz0zMCBCPTEyMSIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjIzNyIgeG1wRzpncmVlbj0iMzAiIHhtcEc6Ymx1ZT0iMTIxIi8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTE5OSBHPTE3OCBCPTE1MyIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjE5OSIgeG1wRzpncmVlbj0iMTc4IiB4bXBHOmJsdWU9IjE1MyIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0xNTMgRz0xMzQgQj0xMTciIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSIxNTMiIHhtcEc6Z3JlZW49IjEzNCIgeG1wRzpibHVlPSIxMTciLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlI9MTE1IEc9OTkgQj04NyIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjExNSIgeG1wRzpncmVlbj0iOTkiIHhtcEc6Ymx1ZT0iODciLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlI9ODMgRz03MSBCPTY1IiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iODMiIHhtcEc6Z3JlZW49IjcxIiB4bXBHOmJsdWU9IjY1Ii8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTE5OCBHPTE1NiBCPTEwOSIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjE5OCIgeG1wRzpncmVlbj0iMTU2IiB4bXBHOmJsdWU9IjEwOSIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0xNjYgRz0xMjQgQj04MiIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjE2NiIgeG1wRzpncmVlbj0iMTI0IiB4bXBHOmJsdWU9IjgyIi8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTE0MCBHPTk4IEI9NTciIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSIxNDAiIHhtcEc6Z3JlZW49Ijk4IiB4bXBHOmJsdWU9IjU3Ii8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTExNyBHPTc2IEI9MzYiIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSIxMTciIHhtcEc6Z3JlZW49Ijc2IiB4bXBHOmJsdWU9IjM2Ii8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTk2IEc9NTYgQj0xOSIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9Ijk2IiB4bXBHOmdyZWVuPSI1NiIgeG1wRzpibHVlPSIxOSIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj02NiBHPTMzIEI9MTEiIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSI2NiIgeG1wRzpncmVlbj0iMzMiIHhtcEc6Ymx1ZT0iMTEiLz4gPC9yZGY6U2VxPiA8L3htcEc6Q29sb3JhbnRzPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6bGk+IDxyZGY6bGk+IDxyZGY6RGVzY3JpcHRpb24geG1wRzpncm91cE5hbWU9IkdyYXlzIiB4bXBHOmdyb3VwVHlwZT0iMSI+IDx4bXBHOkNvbG9yYW50cz4gPHJkZjpTZXE+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTAgRz0wIEI9MCIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjAiIHhtcEc6Z3JlZW49IjAiIHhtcEc6Ymx1ZT0iMCIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0yNiBHPTI2IEI9MjYiIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSIyNiIgeG1wRzpncmVlbj0iMjYiIHhtcEc6Ymx1ZT0iMjYiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlI9NTEgRz01MSBCPTUxIiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iNTEiIHhtcEc6Z3JlZW49IjUxIiB4bXBHOmJsdWU9IjUxIi8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTc3IEc9NzcgQj03NyIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9Ijc3IiB4bXBHOmdyZWVuPSI3NyIgeG1wRzpibHVlPSI3NyIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0xMDIgRz0xMDIgQj0xMDIiIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSIxMDIiIHhtcEc6Z3JlZW49IjEwMiIgeG1wRzpibHVlPSIxMDIiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlI9MTI4IEc9MTI4IEI9MTI4IiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iMTI4IiB4bXBHOmdyZWVuPSIxMjgiIHhtcEc6Ymx1ZT0iMTI4Ii8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTE1MyBHPTE1MyBCPTE1MyIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjE1MyIgeG1wRzpncmVlbj0iMTUzIiB4bXBHOmJsdWU9IjE1MyIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0xNzkgRz0xNzkgQj0xNzkiIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSIxNzkiIHhtcEc6Z3JlZW49IjE3OSIgeG1wRzpibHVlPSIxNzkiLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlI9MjA0IEc9MjA0IEI9MjA0IiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iMjA0IiB4bXBHOmdyZWVuPSIyMDQiIHhtcEc6Ymx1ZT0iMjA0Ii8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTIzMCBHPTIzMCBCPTIzMCIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjIzMCIgeG1wRzpncmVlbj0iMjMwIiB4bXBHOmJsdWU9IjIzMCIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0yNDIgRz0yNDIgQj0yNDIiIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSIyNDIiIHhtcEc6Z3JlZW49IjI0MiIgeG1wRzpibHVlPSIyNDIiLz4gPC9yZGY6U2VxPiA8L3htcEc6Q29sb3JhbnRzPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6bGk+IDxyZGY6bGk+IDxyZGY6RGVzY3JpcHRpb24geG1wRzpncm91cE5hbWU9IldlYiBDb2xvciBHcm91cCIgeG1wRzpncm91cFR5cGU9IjEiPiA8eG1wRzpDb2xvcmFudHM+IDxyZGY6U2VxPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj02MyBHPTE2OSBCPTI0NSIgeG1wRzptb2RlPSJSR0IiIHhtcEc6dHlwZT0iUFJPQ0VTUyIgeG1wRzpyZWQ9IjYzIiB4bXBHOmdyZWVuPSIxNjkiIHhtcEc6Ymx1ZT0iMjQ1Ii8+IDxyZGY6bGkgeG1wRzpzd2F0Y2hOYW1lPSJSPTEyMiBHPTIwMSBCPTY3IiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBHOnJlZD0iMTIyIiB4bXBHOmdyZWVuPSIyMDEiIHhtcEc6Ymx1ZT0iNjciLz4gPHJkZjpsaSB4bXBHOnN3YXRjaE5hbWU9IlI9MjU1IEc9MTQ3IEI9MzAiIHhtcEc6bW9kZT0iUkdCIiB4bXBHOnR5cGU9IlBST0NFU1MiIHhtcEc6cmVkPSIyNTUiIHhtcEc6Z3JlZW49IjE0NyIgeG1wRzpibHVlPSIzMCIvPiA8cmRmOmxpIHhtcEc6c3dhdGNoTmFtZT0iUj0yNTUgRz0yOSBCPTM3IiB4bXBHOm1vZGU9IlJHQiIgeG1wRzp0eXBlPSJQUk9DRVNTIiB4bXBH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\n",
        width: 70
      }
    ]
  };


  layout = {
    fillColor: function (rowIndex) {
      return (rowIndex === 0) ? "#f1f1f1" : null;
    },
    hLineWidth: function (i, node) {
      return (i === 0 || i === node.table.body.length) ? 1 : 1;
    },
    vLineWidth: function (i, node) {
      return (i === 0 || i === node.table.widths.length) ? 1 : 1;
    },
    hLineColor: function (i, node) {
      return (i === 0 || i === node.table.body.length) ? "black" : "#f1f1f1";
    },
    vLineColor: function (i, node) {
      return (i === 0 || i === node.table.widths.length) ? "black" : "#f1f1f1";
    }
  };


  /**
   * Passes if the string contains an HTML anchor, e.g. `<a href="...">...</a>`
   */
  private readonly _anchorRegex = /<a.*?<\/a>/gi;

  /**
   * Passes if the string contains an HTML image, e.g. `<img src="..." />`
   */
  private readonly _imgRegex = /<img.*\/?>/gi

  private readonly _labelColumnWidth = 130;

  /**
   * Passes if the whole string matches an http- or https-based URL, e.g. `https://www.cinchy.net`
   */
  private readonly _urlRegex = /^(?:http(?:s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:\/?#[\]@!\$&'\(\)\*\+,;=.%]+$/i

  private readonly _valueColumnWidth = "80%";


  constructor(
    private _appStateService: AppStateService,
    private _childFormService: ChildFormService,
    private _notificationService: NotificationService,
    private _spinnerService: NgxSpinnerService,
    @Inject(LOCALE_ID) public locale: string
  ) {}


  async generatePdf(form: Form, currentRow: ILookupRecord, settings: IExportSettings): Promise<void> {

    await this._spinnerService.show();

    this.content = [
      {
        text: this._appStateService.formMetadata.formName,
        style: "formHeader"
      }
    ];

    currentRow?.label && this.content.push({ text: currentRow.label, style: "formSubHeader" });

    const documentDefinition = await this._getDocDefFromForm(form, settings);

    if (documentDefinition) {
      const fileName = currentRow?.label ? `${this._appStateService.formMetadata.formName}-${currentRow.label}.pdf` : `${this._appStateService.formMetadata.formName}.pdf`;

      setTimeout(async (): Promise<void> => {

        pdfMake.createPdf(documentDefinition).download(fileName);

        await this._spinnerService.hide();
      }, 300);
    }
    else {
      this._notificationService.displayWarningMessage("Nothing to print");

      await this._spinnerService.hide();
    }
  }


  /**
   * Fetches the given imageUrl in order to render the image, then take that result and encodes it into a base64 string that can
   * be injected directly into a PDF.
   */
  async getBase64ImageFromUrl(imageUrl: string): Promise<string> {

    const response = await fetch(imageUrl);

    if (response.status < 400) {
      const blob = await response.blob();

      return new Promise((resolve, reject) => {

        const reader = new FileReader();

        reader.addEventListener("load", () => {

          resolve(reader.result as string);
        }, false);

        reader.onerror = () => {

          return reject(this);
        };

        reader.readAsDataURL(blob);
      });
    }
    else {
      return Promise.reject(`Failed to fetch image from URL: ${imageUrl} (${response.status}: ${response.statusText})`);
    }
  }


  /**
   * Constructs an array containing HTML elements which match the given regex. The input text will be split into sets of matching HTML elements and
   * non-matching plaintext, and will alternate adding those in so that the ordering of the original value is maintained.
   */
  private _generateArrayFromHtml(
    textValue: string,
    htmlItemRegex: RegExp
  ): Array<string | { text: string, link: string, style: string } | { image: any, height?: number, width?: number }> {

    const returnValues = new Array<string | { text: string, link: string, style: string } | { image: any, height?: number, width?: number }>();

    const allTargets = textValue.match(htmlItemRegex);
    const allNonTargets = textValue.split(htmlItemRegex);

    // If there is text before the first item, we want to preserve that
    if (allNonTargets.length && textValue.indexOf(allNonTargets[0]) === 0) {
      const firstNonTargetItem = allNonTargets.shift();

      if (firstNonTargetItem?.length) {
        returnValues.push(firstNonTargetItem);
      }
    }

    for (let index = 0; index < allTargets.length; index++) {
      if (this._isHtmlAnchor(textValue)) {
        returnValues.push(...this._generateAnchorArrayItemFromHtml(allTargets[index], allNonTargets[index]));
      }
      else {
        returnValues.push(...this._generateImageArrayItemFromHtml(allTargets[index], allNonTargets[index]));
      }
    }

    return returnValues;
  }


  /**
   * Generates a structure representing one pair of [HTML anchor, non-anchor trailing text]. Will ignore the trailing text if it is falsey.
   */
  private _generateAnchorArrayItemFromHtml(targetItem: string, adjacentNonTargetItem: string, labelOverride?: string):
      Array<string | { text: string, link: string, style: string }>
  {

    const returnValues = new Array<string | { text: string, link: string, style: string }>();

    const anchorElementWrapper = document.createElement("template");

    anchorElementWrapper.innerHTML = targetItem.trim();

    returnValues.push({
      text: labelOverride ?? (anchorElementWrapper.content.firstChild as HTMLAnchorElement).text,
      link: (anchorElementWrapper.content.firstChild as HTMLAnchorElement).href,
      style: "anchor"
    });

    if (adjacentNonTargetItem?.length) {
      returnValues.push(adjacentNonTargetItem);
    }

    return returnValues;
  }


  /**
   * Generates a structure representing one pair of [HTML image, non-image trailing text]. Will ignore the trailing text if it is falsey.
   */
  private _generateImageArrayItemFromHtml(targetItem: string, adjacentNonTargetItem: string, width = 24): Array<string | { image: any, height?: number, width?: number }> {

    const returnValues = new Array<string | { image: any, height?: number, width?: number }>();

    const sourceUrl = targetItem.match(/src="([^\"]*)"/i)[1];

    // Note: this is a promise. The promise will resolve as part of the _resolveImagePromises function call
    const image = this.getBase64ImageFromUrl(sourceUrl);

    returnValues.push({
      image: image,
      width: width
    });

    if (adjacentNonTargetItem?.length) {
      returnValues.push(adjacentNonTargetItem);
    }

    return returnValues;
  }


  /**
   * Generates a structure representing the given child form table
   */
  private _getChildFormTable(childForm: Form): {
      table?: {
        headerRows: number,
        body: Array<any>,
        widths: Array<any>
      },
      sectionHeader?: {
        text: any,
        bold: boolean,
        style?: string
      },
      layout?: any
  } {

    const table = this._getDefaultTable();
    const tbody = new Array<Array<any>>();

    const fieldKeys = this._childFormService.getFieldKeys(childForm)?.filter((field: string) => {

      return (field !== "Cinchy ID" && field !== "Actions");
    });

    const displayValueMap = this._childFormService.getDisplayValueMap(childForm);

    if (fieldKeys?.length && displayValueMap?.length) {
      const fields = this._childFormService.getAllFields(childForm);

      tbody.push(fieldKeys.map((key: string) => {

        return {
          text: this._childFormService.getFieldByKey(fields, key)?.label ?? key,
          style: "tableHeader"
        };
      }));

      displayValueMap.forEach((rowValues: { [key: string]: string }) => {

        tbody.push(fieldKeys.map((field: string) => {

          if (this._isHtmlImage(rowValues[field])) {
            return {
              columns: this._generateArrayFromHtml(rowValues[field], this._imgRegex),
              style: "tableRow"
            };
          }
          else {
            return {
              text: this._processChildFormTableValue(rowValues, field),
              style: "tableRow"
            };
          }
        }));
      });

      table.body = tbody.slice();

      table.widths = new Array<string>(fieldKeys.length).fill("auto");

      return {
        table: table,
        sectionHeader: { ...this.sectionHeaderDefault, text: childForm.sections[0].label },
        layout: this.layout
      }
    }
    else {
      table.body = table.widths = [];

      return {};
    }
  }


  /**
   * @returns the default structure for a table. Headers are automatically repeated if the table spans over multiple pages.
   */
  private _getDefaultTable(headerRows = 1): {
      headerRows: number,
      body: Array<any>,
      widths: Array<any>
  } {

    return {
      headerRows: headerRows,
      body: [],
      widths: []
    }
  }


  /**
   * Builds the PDF structure for PDFMake
   */
  private async _getDocDefFromForm(form: Form, settings: IExportSettings): Promise<any> {

    if (form?.sections?.length) {
      form.sections.forEach((section: FormSection) => {

        this.content.push({ ...this.sectionHeaderDefault, text: section.label });

        this._setFieldsForSection(section);
      });

      const resolvedContent = await this._resolveImagePromises(this.content);

      return {
        header: this.header,
        content: resolvedContent,
        styles: this.styles,
        pageSize: PageSize.Letter,
        pageMargins: [30, 62, 62, 30],
        pageOrientation: settings.pageOrientation ?? PageOrientation.Portrait,
        footer: function (currentPage: number, pageCount: number) {

          return {
            text: `${currentPage.toString()} of ${pageCount}`,
            style: "footer"
          }
        }
      };
    }

    return null;
  }


  /**
   * Generates a structure that represents the label and value for the given field. Will render HTML anchors as clickable links
   * and include a placeholder value for fields which are not populated.
   */
  private _getFieldColumns(field: FormField, overrideValue?: any): Array<any> {

    const result: Array<{
        marginRight?: number | string,
        style: string,
        text?: string | Array<any>,
        width: number | string
    }> = [
      {
        style: "fieldLabel",
        text: `${field.label}: `,
        width: this._labelColumnWidth
      }
    ];

    const valueColumn: {
      marginRight?: number | string,
      style: string,
      text?: string | Array<any>,
      width: number | string
    } = {
      marginRight: 15,
      style: "fieldValue",
      width: this._valueColumnWidth
    };

    if (overrideValue) {
      valueColumn.text = overrideValue
    }
    else if (this._isHtmlAnchor(field.value)) {
      valueColumn.text = this._generateArrayFromHtml(field.value, this._anchorRegex);
    }
    else {
      valueColumn.text = field.value || "-";
    }

    result.push(valueColumn);

    return result;
  }


  /**
   * Generates a structure that represents a the label and value for a field that contains an image. At
   * this stage, the value is a promise that will be resolved at a later step.
   */
  private _getImageColumns(field: FormField, value: any): Array<any> {

    const returnValues: Array<any> = [
      {
        width: this._labelColumnWidth,
        text: `${field.label}: `,
        style: "fieldLabel"
      }
    ];

    if (this._isHtmlImage(field.value)) {
      returnValues.push(
        {
          columns: this._generateImageArrayItemFromHtml(field.value, null, 80),
          width: this._valueColumnWidth
        }
      );
    }
    else if (!field.hasValue) {
      returnValues.push({
        text: "-",
        style: "fieldValue"
      });
    }
    else {
      returnValues.push(
        {
          columns: [
            {
              image: value,
              width: 80
            }
          ],
          width: this._valueColumnWidth
        }
      );
    }

    return returnValues;
  }


  /**
   * Generates a structure that represents the label and value for a field which contains a URL
   */
  private _getLinkColumns(field: FormField, anchorTextOverride?: string): Array<any> {

    const returnValues: Array<any> = [
      {
        width: this._labelColumnWidth,
        text: `${field.label}: `,
        style: "fieldLabel"
      }
    ];

    if (this._isHtmlAnchor(field.value)) {
      returnValues.push(this._generateAnchorArrayItemFromHtml(field.value, null, "Open"));
    }
    else if (!field.hasValue) {
      returnValues.push(
        {
          text: "-",
          style: "fieldValue"
        }
      );
    }
    else {
      returnValues.push(
        {
          text: anchorTextOverride || field.value,
          link: field.value,
          style: "anchor"
        }
      );
    }

    return returnValues;
  }


  /**
   * Gets the display values associated with the given link fink
   */
  private _getLinkFieldLabelAndValue(field: FormField): {
      label: string,
      value: string
  } {

    const dropdownSet: Array<DropdownOption> = field.dropdownDataset?.options;

    if (dropdownSet && field.cinchyColumn.isMultiple) {
      let selectedOptions;

      const fieldValues = (field.value instanceof Array ? field.value : field.value?.split(",")) || [];

      if (fieldValues?.length) {
        selectedOptions = dropdownSet.filter((option: DropdownOption) => {

          return fieldValues.find((id: string) => {

            return (option.id === id?.trim());
          });
        });
      }

      return {
        label: field.label,
        value: selectedOptions?.map(option => option.label).join(", ") || ""
      }
    } else if (dropdownSet) {
      const selectedOption = dropdownSet.find(option => option.id === field.value);

      return {
        label: field.label,
        value: selectedOption?.label
      };
    }
    return {
      label: field.label,
      value: "-"
    };
  }


  /**
   * Determines whether or not the given text contains an HTML anchor
   */
  private _isHtmlAnchor(textValue: string): boolean {

    // Global RegExp are stateful, so in order to ensure this test is independent we need to manually reset it
    this._anchorRegex.lastIndex = 0;

    return this._anchorRegex.test(textValue);
  }


  /**
   * Determines whether or not the given text contains an HTML image.
   */
  private _isHtmlImage(textValue: string): boolean {

    // Global RegExp are stateful, so in order to ensure this test is independent we need to manually reset it
    this._imgRegex.lastIndex = 0;

    return this._imgRegex.test(textValue);
  }


  /**
   * Determines whether or not the given text is a URL
   */
  private _isUrl(textValue: string): boolean {

    return coerceBooleanProperty(textValue && this._urlRegex.test(textValue));
  }


  /**
   * If the given value is contains an anchor tag or an image, then we want to render that in the output. Otherwise, just pass the value
   * through, as it has already been processed
   */
  private _processChildFormTableValue(
      displayValueMap: { [key: string]: any },
      field: string
  ): string | Array<string | { text: string, link: string, style: string } | { image: any, height?: number, width?: number }> {

    const textValue: string = displayValueMap[field];

    // Could be either an anchor on its own, or any number of anchors in a paragraph of text
    if (this._isHtmlAnchor(textValue)) {
      return this._generateArrayFromHtml(textValue, this._anchorRegex);
    }
    else if (this._isHtmlImage(textValue)) {
      return this._generateArrayFromHtml(textValue, this._imgRegex);
    }
    else {
      return textValue || "-";
    }
  }


  /**
   * Adds content to the document representing the given field
   */
  private async _pushFields(
      field: FormField,
      selectedOptionField?: {
        label: string,
        value: string
      }
  ): Promise<void> {

    const fieldCopy = field.clone();

    if (selectedOptionField) {
      fieldCopy.value = selectedOptionField.value;
      fieldCopy.label = selectedOptionField.label;
    }

    if (fieldCopy.value && fieldCopy.cinchyColumn.dataFormatType?.startsWith(DataFormatType.ImageUrl)) {
      let imageUrl: string;

      if (this._isHtmlImage(fieldCopy.value) || this._isUrl(fieldCopy.value)) {
        imageUrl = fieldCopy.value;
      }
      else {
        // Only use the dropdownDataset if it was an option explicitly generated to be a placeholder in a prepopulated set. Otherwise,
        // we could just be puling in a value for an arbitrary file in the set of those associated with this form
        imageUrl = (fieldCopy.dropdownDataset?.isDummy ? fieldCopy.dropdownDataset.options[0]?.label : fieldCopy.value) || fieldCopy.value;
      }

      if (this._isUrl(imageUrl)) {
        const base64Img = this.getBase64ImageFromUrl(imageUrl);

        this.content.push({ columns: this._getImageColumns(fieldCopy, base64Img) });
      }
      else {
        // We specifically want to use the preprocessed imageUrl field in case it was populated using the dropdownDataset but still isn't a valid URL
        this.content.push({ columns: this._getFieldColumns(fieldCopy, imageUrl) });
      }
    }
    // If the field was designated as a link, then we want to override the label to keep the behaviour consistent with earlier versions
    else if (field.cinchyColumn.dataFormatType === "LinkUrl") {
      this.content.push({ columns: this._getLinkColumns(fieldCopy, "Open") });
    }
    else if (fieldCopy.cinchyColumn.dataType === "Date and Time") {
      if (fieldCopy.value) {
        const dateAsMoment = moment(fieldCopy.value);

        if (dateAsMoment.isValid) {
          this.content.push({
            columns: this._getFieldColumns(fieldCopy, dateAsMoment.format(fieldCopy.cinchyColumn.displayFormat || "MM/DD/yyyy"))
          });
        }

      }
      else {
        this.content.push({ columns: this._getFieldColumns(fieldCopy) });
      }
    }
    else {
      this.content.push({ columns: this._getFieldColumns(fieldCopy) });
    }
  }


  /**
   * Handles the resolution of an image promise within an actual image object. Any input to this function is considered to be
   * a leaf node, so it will not recurse.
   */
  private async _resolveIndividualImagePromise(
      item: { image: any, height?: number, width?: number }
  ): Promise<{ image: any, height?: number, text?: string, width?: number }> {

    try {
      const result = await item.image;

      // a string starting with data:image is assumed to be an encoded image, but if the last character is a comma
      // then the image did not successfully resolve
      if (result?.includes("data:image") && result[result.length - 1] !== ",") {
        // Clone any other properties, but ensure that the image property contains the new data
        return { ...item, image: result };
      }
      else {
        if (result?.includes("error")) {
          console.error(result);
        }

        // If the promise resolves into an invalid value, i.e. the image could not be found, then just return an empty value
        return { ...item, text: "-", image: null };
      }
    }
    catch (error) {
      // Just use a default in the case of an error
      return { ...item, text: "-", image: null };
    }
  }


  /**
   * Recursively iterates through the content and resolves any outstanding promises for images.
   *
   * TODO: the types are "any" because properly typing this function would be too verbose for the current ticket. There will
   *       be a chore to properly type all of the PDF library types used by this application
   */
  private async _resolveImagePromises(content: any): Promise<any> {

    if (Array.isArray(content)) {
      return Promise.all(content.map((item: any) => {

        return this._resolveImagePromises(item);
      }));
    }
    else if (content?.image && content.image instanceof Promise) {
      return this._resolveIndividualImagePromise(content);
    }
    else if (content && typeof content === "object") {
      return this._resolveImagePromisesFromObjectProperties(content);
    }
    else {
      return Promise.resolve(content);
    }
  }


  /**
   * Dives into the given objects individual properties so that the recursive _resolveImagePromises can guarantee it touches
   * every node in the tree.
   */
  private async _resolveImagePromisesFromObjectProperties(originalObject: any): Promise<any> {

    const output = {};

    await Promise.all(
      Object.keys(originalObject).map(async (key: string) => {

        output[key] = await this._resolveImagePromises(originalObject[key]);
      })
    );

    return output;
  }


  /**
   * Iterates through the fields in the given section and adds each to the document
   */
  private _setFieldsForSection(section: FormSection): void {

    section.fields?.forEach((field: FormField) => {

      if (field.childForm) {
        const result = this._getChildFormTable(field.childForm);

        if (result.table) {
          this.content.push(result);
        }
      } else {
        switch (field.cinchyColumn.dataType) {
          case "Link":
            const selectedOptionField = this._getLinkFieldLabelAndValue(field);

            this._pushFields(field, selectedOptionField);

            break;
          default:
            if (field.label !== "Actions") {
              this._pushFields(field);
            }
        }
      }
    });
  }
}
